#include <stdio.h> // для всего примитивного типо принтф сканф
#include <stdlib.h> // для выделения динамической памяти - каллоки маллоки реаллоки
#include <time.h> // для рандома - сранд(тайм(нулл)
#include <stdbool.h> // для переменных типа boolean

#define ARRAY_SIZE 10 // размер массива
#define RANDOM_INTERVAL 10 // интервал для рандома

typedef struct tree // структура
{
	int data; // данные
	int balance; // баланс
	struct tree* left; // левое поддерево
	struct tree* right; // правое поддерево
}vertex; // синоним

bool growth = false; // глобальная переменная роста (курапова говорила делать глобальной - не ебу зачем и мне впадлу таскать ее локально туда сюда)
//присвоил false потому что в первый раз когда дерево подается оно все равно без роста(когда корня нет) 
//инициализировать переменные вроде как хороший тон(инициализирует обычно нулевыми значениями чтобы не было мусора чтобы если что то пошло по пизде то у тебя не с мусором работалось а с нулем и это было не так критично и проще было бы вылавливать баг исключая ситуацию когда вывод чудом совпал с мусором) (мазани что так говрили по трпо(вроде))
void Print_Avl(vertex* root) // функция обхода слева направо
{
	if (root != NULL) // пока не уперлись в пустое поддерево
	{
		Print_Avl(root->left); // обход с левым поддерево (рекурсия(рекурсия запускается и следующий принт не деалется пока функция не завершится)) !!!!а почему рекурсия?!!!
		printf("%d ",root->data); // печать данных дерева
		Print_Avl(root->right); // обход правого поддерева (рекурсия(та же хуйня что и с левым - правила рекурсии одинаковы))
	}
}

vertex* Add_In_Avl(vertex* root, int value) // функция добавления вершины в авл дерево
{
	vertex* pointer = NULL; // дополнительный указатель
	if(root == NULL) // если дерево пустое (оно же может быть и поддеревом - каждое поддерево = мини дерево)
	{
		root = (vertex*) malloc (1 * sizeof(vertex)); // выделяем память для вершины 
		root->data = value; // записываем в нее переданные данные
		root->left = NULL; // зануляем указатель на левое поддерево
		root->right = NULL; // зануляем указатель на правое поддерево
		root->balance = 0; // выравниваем баланс(т.к. у этой вершины нет поддеревьев(занулены выше))
		growth = true; // переменная роста - тру - рост произошел (индикатор того что вершина была добавлена)
	}
	else // если дерево не пус пустое
	{//сначала идет работа с левым поддеревом(его проверка и т.д.)
		if(value <= root->data) // если добавляемое значение меньше чем имеющееся в дереве(или равно(когда равно принято добавлять в левое хз почему кто то говорил))
		{
			pointer = root->left; // присваем указателю ссылку на левое поддерево дерева
			pointer = Add_In_Avl(pointer,value); // запускаем рекурсию но уже для нового(нового относительно корня) указателя
			root->left = pointer; // правому поддереву пришиваем полученное поддерево при добавлении значения
			if(growth == true) // если был рост == если есть "выпирающая вершина"
			{
				if(root->balance > 0) // если баланс был больше нуля(справа была вершина а слева нет у исходного дерева) 
				{
					root->balance = 0;// зауляем баланс(т.к. он выровнялся после добавлления вершины влево(справа и слева стало по одной(одинаковому количеству) вершине))
					growth = false; // зануляем переменную роста(т.к. баланс выровнялся)
				}
				else //иначе если баланс был не больше нуля(не было перевеса вправо) и соответсвенно после добавления влево не выровнялся
				{
					if (root->balance == 0) // если баланс был равным нулю(количество вершин были одинаковы справа и слева)
					{
						root->balance = -1;// делаем баланс равным -1(перевес влево от нуля - слева на одну вершину больше)
						 // рост не был занулен так как осталась "выпирающая вершина" с не нулевым балансом
					}
					else // инчае то есть если баланс был и так отрицательным(слева было больше поддеревьев)
					{ // начинаем проверять баланс у поддерева(левого) дерева
						if (root->left->balance < 0) // сравниваем баланс в левом поддереве - если он меньше нуля(слева есть вершина а справ нет)
						{
							/*FUNCTION_LEFT_LEFT_TURN*/
						}
						else// иначе(если баланс больше нуля(на равенство было проверено выше и если сюда пришло то точно не равен))
						{
							/*FUNCTION_LEFT_RIGHT_TURN*/
						}
					}
				}
			}
		}//работа с левым поддеревом закончена
		else
		{//начинается работа с правым поддеревом(если не было работы с левым)
			if (value > root->data) // если добавляемое значение больше текущего значения в дереве
			{// скорее всего этот иф для наглядности так как выше мы проверили уже значение на <= соответсвенно else в любом случае >
				pointer = root->right; // присваем указателю ссылку на правое поддерево дерева
				pointer = Add_In_Avl(pointer,value); // вызывем функцию добавления в дерево рекурсивно
				root->right = pointer; // правому поддереву пришиваем полученное поддерево при добавлении значения
				if (growth == true) // если есть "выпирающая вершина"
				{
					if(root->balance < 0) //если баланс меньше нуля(слева есть поддерево)
					{
						root->balance = 0; // зануляем баланс т.к. добавили вершину вправо и баланс выровнился
						growth = false; // обнуляем рост(т.к. баланс выровнялся)
					}
				}
				else //иначе если баланс был не меньше нуля(не было перевеса влево) и соответсвенно после добавления вправо не выровнялся
				{
					if (root->balance == 0) // если баланс был равен нулю
					{
						root->balance = 1; // делаем баланс равным единице(на один вправо больше от нуля) т.к. справа тепперь на одну вершину больше
						 // рост не был занулен так как осталась "выпирающая вершина" с не нулевым балансом
					}
					else // иначе если баланс не был равен нулю т.е. был и так перевес вправо
					{ // начинаем проверять баланс у поддерева(правого) дерева
						if (root->right->balance > 0) // если правое поддерево дерева имеет баланс больший нуля(справа есть поддерево у поддерева)
						{
							/*FUNCTION_RIGHT_RIGHT_TURN*/
						}
						else // иначе если у правого поддерева нет перевеса вправо 
						{
							/*FUNCTION_RIGHT_LEFT_TURN*/
						}
					}
				}
			}
		}
	}
	return root; // возвращаем указатель корня(изменного глобально(оносительно корня имеется ввиду) поддерева)
}

int* Fill_Rand(int* array) // функция заполнения массива псевдо рандомными числами
{
	array = (int*) calloc (ARRAY_SIZE, sizeof(int)); // выделяем память под массив память указанному в макросе количесвта элементов
	for(short int i = 0; i < ARRAY_SIZE; i++) // цикл от первого и до последнего(от нуля до сайз-1)
	{
		array[i] = rand()%RANDOM_INTERVAL;//присвоить итому элементу массива значение остатка от деления возвращаемого значения функцией ранд на значение в макросе интервала рандома 
	}
	return array; // возвращаем указатель на измененный массив
}

int main() // точка входа в программу
{
	vertex* root = NULL; // инициализируем корень дерева (тип данных - вертекс - структура)
	int* array = NULL; // инициализируем указатель на одномерны массив
	srand(time(NULL)); //вызываем функцию сранда
	array = Fill_Rand(array); // вызываем функцию заполнения массива(там же выделение памяти) и присваиваем указателю на массив возвращаемое значение функции
	for(short int i = 0; i < ARRAY_SIZE; i++) // цикл от начала и до конца массива 
	{
		root = Add_In_Avl(root,array[i]); // корню возвращаем значения функции добавления вершины в авл дерево(в качестве параметров корень имеющегося дерева и итый элемент массива)
	}
	Print_Avl(root); // вызываем функцию печати дерева(обход слева направо)
	return 0; // завершаем программу со значением 0 - отсутсвие критических ошибок
}
